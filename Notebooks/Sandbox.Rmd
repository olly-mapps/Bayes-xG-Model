---
title: "Sandbox"
output:
  html_document:
    df_print: paged
    toc: yes
---

# Libraries

```{r}
library(tidyverse)
library(MASS)
library(rstanarm)
library(data.table)
library(ggsoccer)
library(jsonlite)
library(gridExtra)
library(stringi)
library(rstan)
library(bayesplot)
```

We also run the following code for making the usage of `rstan` easier later on.

```{r}
options(mc.cores = parallel::detectCores())
rstan_options(auto_write = TRUE)
```

# Data Loading

We first want to load in the events data, which split across multiple csv files, grouped by country. To read this in, I have defined a loop that iterates through the data directory and appends each file to a data-frame.

```{r}
#Define Data Directory
dir_path <- "../Data/events"

#Get a list of files in the directory
file_list <- list.files(dir_path)

#Create an empty data frame to store the file contents
actions <- data.frame()

#Loop through the files and add their contents to the data frame
for (i in 1:length(file_list)) {
  #Read the file into a data frame
  file_data <- fread(file.path(dir_path, file_list[i]))
  
  #Add the file data to the main data frame
  actions <- rbind(actions, file_data)
}
```

```{r}
#View the events data frame
actions
```

We next want to load in the player data

```{r}
#Read in data
players <- fromJSON("../Data/players/players.json")
```

```{r}
#View player data
players
```

Since the event data contains all sorts of event types, we now want to filter out only the shots.

```{r}
# Extract observations of shots from the actions data 
shots_df <- actions %>% dplyr::filter(subEventName == "Shot")
```

## Event Data

The next section is dedicated to loading the event data

### Categorical Data

We now use documentation from [here](https://dataglossary.wyscout.com/shot/) to mutate the data, and garner more useful categorical data about the shot itself.

```{r}
shots_df <- shots_df %>% 
  
  #If the shot is successful
  mutate('is_goal' = ifelse(grepl(" 101}", shots_df$tags),1,0), 
         
         #If the shot is at the end of a counter-attack
         'is_CA' = ifelse(grepl(" 1901}", shots_df$tags),1,0),
         
         #If the shot is with the foot or another part of the body
         'body_part' = ifelse(grepl(" 401}", shots_df$tags),"left",
                              ifelse(grepl(" 402}", shots_df$tags), "right", 
                                   ifelse(grepl(" 403}", shots_df$tags), "head/body", "NA"))),
         
         #If the shot is blocked
         'is_blocked' = ifelse(grepl(" 2101}", shots_df$tags), 1,0))

#Filter out only unblocked shots
shots_df <- shots_df %>% dplyr::filter(is_blocked == 0)

#Keep necessary categorical data
shots_cat <- dplyr::select(shots_df, c('playerId', 'is_goal', 'is_CA', 'body_part'))

summary(shots_cat)
```

### Positional Data

We now calculate the distance from the goal and angle to goal for each shot.

First, we would like to define the position of each shot on the pitch

```{r}
#Extract all numeric entries from the positions column
pos <- str_extract_all(gsub('"', "", shots_df$positions), "\\d+")

#Define vectors to store coordinates
x_pos <- c()
y_pos <- c()

#Loops that extract the coordinates
for (i in 1:length(pos)){
  x_pos <- append(x_pos, pos[[i]][2])
}

for (i in 1:length(pos)){
  y_pos <- append(y_pos, pos[[i]][1])
}

#Convert coordinates to numeric data
x_pos <- x_pos %>% as.numeric()
y_pos <- y_pos %>% as.numeric()
```

```{r}
# Create coordinate dataframe
coords <- data.frame(x_pos, y_pos)
```

We can now use these coordinates to calculate distance and angle to goal

```{r}
#Define length and width of pitch

pitch_x <- 105
pitch_y <- 68

#We now convert coordinates to meters
x_meter <- coords$x_pos * pitch_x/100
y_meter <- coords$y_pos * pitch_y/100

# Calculate distances
dist <- sqrt((105 - x_meter)^2 + ((32.5) - y_meter)^2)

#Calculate angles
angles <- atan( (7.32 * (105 - x_meter) ) / ( (105 - x_meter)^2 + (32.5 - y_meter)^2 - (7.32/2)^2 )) * 180/pi
```

We can now merge our useful event data into one data-frame.

```{r}
#Concatenate data-frames
shots <- data.frame(shots_cat, dist, angles)
```

## Player Data

The next section is dedicated to loading the player data. For this, we simply filter only by the features that will prove useful later on.

First lets retrieve a vector of all unique players in the current `shots` data-base:

```{r}
#Retrieves unique player ids
player_list <- unique(shots$playerId)
```

We can now filter the `players` data-frame to only include these players

```{r}
#Filters by player ids between both data frames
shooters <- dplyr::filter(players, wyId %in% player_list)
```

We can filter this data-frame by the features we need.

```{r}
#Selects necessary columns
shooters <- dplyr::select(shooters, c('shortName', 'wyId', 'foot'))
```

Finally, we rename the some columns, for ease later on.

```{r}
#Renames columns
colnames(shooters)[colnames(shooters) == "wyId"] <- "playerId"
colnames(shooters)[colnames(shooters) == "foot"] <- "preferred_foot"
```

### Preferred Foot Data

We will now introduce a preferred foot binary variable.

First we merge all our useful data into one data-frame

```{r}
#Concatenate data-frames
shots <- merge(shots, shooters, by = "playerId")
```

We now mutate this to add a column featuring the desired binary variable

```{r}
#Adds preferred foot binary column
shots <- shots %>% 
  mutate(preferred_foot_b = ifelse(shots$preferred_foot == shots$body_part, 1, 0))
```

Finally, we remove the `preferred_foot` column

```{r}
#Removes desired column
shots <- shots %>% dplyr::select(-c("preferred_foot"))
```

## Data Cleaning/Wrangling

Since much of our data is categorical, it is necessary to convert it to the factor type.

```{r}
#Convert necessary variables to factor 

shots$is_goal <- shots$is_goal %>% as.factor()

shots$body_part <- shots$body_part %>% as.factor()

shots$is_CA <- shots$is_CA %>% as.factor()

shots$preferred_foot_b <- shots$preferred_foot_b %>% as.factor()

shots$shortName <- shots$shortName %>% as.factor()
```

Now lets view a summary of our data

```{r}
summary(shots)
```

### Player Names

If we view a random subset of our data, we observe a problem decoding unicode characters:

```{r}
shots[90:100,]
```

So we use the following chunk to decode them

```{r}
shots$shortName <- stringi::stri_unescape_unicode(shots$shortName)
```

### Negative Angles

We can see from the summary there are negative angles in the data, to investigate this further we can look at a histogram

```{r}
hist(shots$angles)
```

We observe that there are multiple negative angles. Since most of the angles are correctly positive, we will remove the negative ones from the analysis.

```{r}
shots <- shots %>% dplyr::filter(shots$angles > 0)
```

To see the corrected histogram

```{r}
hist(shots$angles)
```

### Player Downsampling

Later on we will use `playerId` to group the data. Since our data-set is large and spans many countries, there are many different players in the data-set

```{r}
length(table(shots$playerId))
```

We see there are 2292 unique player included in the data-set

With this in hand, it would be sensible to limit the amount of "groups" (players) to, say 50. In order to preserve the greatest amount of data, we will use the top 50 most occurring player names.

```{r}
top_players <- sort(table(shots$playerId), decreasing = T)[1:50]
```

Now we filter the data based on these players

```{r}
top_shots <- dplyr::filter(shots, playerId %in% row.names(top_players))
```

We now view a summary of our final data

```{r}
summary(top_shots)
```
### Numbering Of Players

In some of our later models, it is necessary to number the players from 1 to 50. This step is carried out below.

```{r}
top_shots$bayes_id <- as.numeric(as.factor(top_shots$shortName)) 
```

# Data Exploration

To better understand our distance and angle data, we can create the following boxplots.

```{r}
#Defines and distance boxplot

dist_boxplot <- ggplot(top_shots, aes(x=is_goal, y=dist, fill = is_goal)) + 
                geom_boxplot() +
                labs(title="Distributions Of Distances Grouped By Shot Outcome", 
                     x="Shot Outcome", 
                     y="Distance To Goal (m)") + 
                coord_flip()

dist_boxplot <- dist_boxplot + guides(fill=guide_legend(title="Goal (1) or Not (0)"))

#Defines angles boxplot

angles_boxplot <- ggplot(top_shots, aes(x=is_goal, y=angles, fill = is_goal)) + 
                  geom_boxplot() + 
                  labs(title="Distributions Of Angles Grouped By Shot Outcome", 
                     x="Shot Outcome", 
                     y="Angle To Goal (Degrees)") +
                  coord_flip()

angles_boxplot <- angles_boxplot + guides(fill=guide_legend(title="Goal (1) or Not (0)"))

#Plots distance boxplot
dist_boxplot
```
```{r}
#Plots angles boxplot
angles_boxplot
```
From these we observe there must is likely some relationship between the outcome of a shot and the position from which it is taken.

We now visualise the frequency at which each player takes a shot

Firstly, we need to wrangle the data a bit more:

```{r}
#Create data-frame from top_players table defined earlier
top_players_df <- data.frame(top_players)

#Rename columns
colnames(top_players_df)[colnames(top_players_df) == "Var1"] <- "playerId"
colnames(top_players_df)[colnames(top_players_df) == "Freq"] <- "shotVolume"

#We add a column containing player name
top_players_df <- merge(top_players_df, distinct(top_shots[, c("playerId", "shortName")]), by = "playerId")

#We create a dataframe where the is_goal variable is numeric
numeric_goals <- top_shots[, c("shortName", "is_goal")]
numeric_goals$is_goal <- as.numeric(as.character(numeric_goals$is_goal))

#We sum up goals scored by player
summed_goals <- numeric_goals %>%
  group_by(shortName) %>% 
  summarise(goals = sum(is_goal))

#Merge to final data-frame
shots_goals <- merge(top_players_df, summed_goals, by = "shortName") 

#Sort in descending order by shot volume
shots_goals <- arrange(shots_goals, desc(shotVolume))
shots_goals$shortName <- shots_goals$shortName %>% as.factor()
```

Now we visualise the results

```{r width = 5}

shots_goals_long <- gather(shots_goals, key = var, value = value, shotVolume, goals)

shots_goals_plot <- ggplot(shots_goals_long, aes(x=reorder(shortName, -value), y = value, fill = var)) +
                    geom_col(position = "identity", width = 0.9) +
                    labs(title="Shots And Goals By Player", 
                     x="Players", 
                     y="Volume") +
                    scale_x_discrete(guide = guide_axis(angle = 60))

shots_goals_plot <- shots_goals_plot + guides(fill=guide_legend(title="Key"))

shots_goals_plot
                    
```
We can see from the plot, that there is some difference in a players ability to convert a shot. We can exploit this difference by adding another level to our models.

# Fitting Models

## Data Splitting

Since our data-set is somewhat small, it would be wise to have an uneven split of test and train data. This is carried out in the following chunk.

```{r}
# Split into test and train subsets
train.size <- 0.8 * nrow(top_shots) 
train <- sample(1:nrow(top_shots), train.size)
test <- -train
shots.train <- top_shots[train, ]
shots.test <- top_shots[test, ]
is_goal.test <-  top_shots$is_goal[test]
```

## Non-Baysian Models

### `is_goal` ~ `dist` 

First we will fit some simple logistic regression models 

```{r}
glm1 <- glm(is_goal ~ dist, data = top_shots, family = binomial())

summary(glm1)
```

### `is_goal` ~ `dist` + `angles`

```{r}
glm2 <- glm(is_goal ~ dist + angles, data = top_shots, family = binomial())

summary(glm2)
```

### `is_goal` ~ `.`

```{r}
glm3 <- glm(is_goal ~ . - shortName - playerId, data = top_shots, family = binomial())

summary(glm3)
```

## Bayesian Linear Regression 

### Single-Level Models

#### `is_goal` ~ `dist`


```{r}
bmod1_list <- list(y = as.numeric(as.character(shots.train$is_goal)),
                 n = dim(shots.train)[1],
                 X = shots.train$dist,
                 
                 n_new = dim(shots.test)[1],
                 X_new = shots.test$dist,
                 
                 beta_mu = 19,
                 beta_sigma = 10)


bmod1 <- stan(file = "../Stan Files/dist.stan", data = bmod1_list, chains = 4, init = 0, seed = 1)
          
```

```{r}
print(bmod1, pars="beta")
```

```{r}
plot(bmod1, pars="beta")
```

```{r}
traceplot(bmod1, pars='beta')
```

```{r}
ext_fit <- extract(bmod1)
mean(apply(ext_fit$y_new, 2, median) == is_goal.test)
```
```{r}
launch_shinystan(bmod1)
```

#### `is_goal` ~ `dist` + `angles`

```{r}
bmod2_list <- list(y = as.numeric(as.character(shots.train$is_goal)),
                 n = dim(shots.train)[1],
                 X = shots.train[c("dist", "angles")],
                 p = 2,
                 
                 n_new = dim(shots.test)[1],
                 X_new = shots.test[c("dist", "angles")],
                 
                 beta_mu_1 = 19,
                 beta_sigma_1 = 10,
                 beta_mu_2 = 30,
                 beta_sigma_2 = 10
                 )


bmod2 <- stan(file = "../Stan Files/dist+angles.stan", data = bmod2_list, chains = 4, init = 0, seed = 1)
```

```{r}
print(bmod2, pars="beta")
```

```{r}
plot(bmod2, pars="beta")
```

```{r}
traceplot(bmod2, pars='beta')
```

```{r}
ext_fit <- extract(bmod2)
mean(apply(ext_fit$y_new, 2, median) == is_goal.test)
```

```{r}
launch_shinystan(bmod2)
```

### Heirarchical Models 

#### `is_goal` ~ `distance` + (1 | `shortName`)

```{r}
bmod3_list <- list(y = as.numeric(as.character(shots.train$is_goal)),
                 n = dim(shots.train)[1],
                 X = shots.train$dist,
                 p = length(unique(shots.train$bayes_id)),
                 player = top_shots$bayes_id,
                 
                 #n_new = dim(shots.test)[1],
                 #X_new = shots.test$dist,
                 
                 beta_mu = 19,
                 beta_sigma = 10,
                 beta_mu_mu = 30,
                 beta_mu_sigma = 10,
                 beta_sigma_rate = 0.5
                 )

bmod3 <- stan(file = "../Stan Files/dist+shortName.stan", data = bmod3_list, chains = 1, init = 0, seed = 1)
```
```{r}
#print(bmod3, pars="beta")
```

```{r}
#plot(bmod3, pars="beta")
```

```{r}
#traceplot(bmod3, pars='beta')
```

```{r}
#ext_fit <- extract(bmod3)
#mean(apply(ext_fit$y_new, 2, median) == is_goal.test)
```

```{r}
#launch_shinystan(bmod3)
```



